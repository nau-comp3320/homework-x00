# encoding: UTF-8
require_relative 'array_pattern_matcher'

module Calculator
  # Represents a node in the abstract syntax tree generated by Parser.
  #
  # The subclasses of this node include:
  #
  # * ExpressionNode
  # * ExpressionPrimeNode
  # * TermNode
  # * TermPrimeNode
  # * FactorNode
  # * BaseNode
  #
  # Note that Token instances form the leaves of the tree.
  #
  class ASTNode
    # An array holding all of the children for this node, which may be empty.
    # Children will either be an ASTNode or a Token.
    attr_reader :children
    # returns the type of the node (:integer or :decimal)
    attr_reader :type
    # returns the numeric value of the node
    attr_reader :value

    # Creates a new node with the given children
    def initialize(*children)
      @children = children
      @type = children.type
      @value = children.value
    end

    # Returns a semi-friendly string representation of the node
    def to_s
      self.class::NODE_TYPE + '[' + @children.join(', ') + ']'
    end

    # Two nodes are equivalent if they have the same class and equivalent
    # children
    def ==(rhs)
      self.class == rhs.class && self.children == rhs.children
    end

    # Used to print a Graphviz directed graph to represent the parse tree
    def to_dot(counter = new_counter, parent = nil)
      id = "N#{counter.()}"
      out = "  #{id} [label=\"#{self.class::NODE_TYPE}\"];\n"
      if parent
        out += "  #{parent} -> #{id};\n"
      end
      if children.empty?
        epsilon_id = "N#{counter.()}"
        out += "  #{epsilon_id} [label=\"ε\"];\n"
        out += "  #{id} -> #{epsilon_id};\n"
      else
        children.each do |child|
          if child.is_a? Calculator::Token
            token_id = "N#{counter.()}"
            out += "  #{token_id} [label=\"#{child.lexeme}\"];\n"
            out += "  #{id} -> #{token_id};\n"
          else
            out += child.to_dot(counter, id)
          end
        end
      end
      out
    end

    # Prints the tree headed by this node is a somewhat user-friendly format
    def print_tree(prefix = '')
      print "#{prefix}#{self.class::NODE_TYPE}"
      if children.empty?
        puts ' = ε'
        puts "#{prefix}    type=#{type}"
        puts "#{prefix}    value=#{value}"
      else
        puts
        puts "#{prefix}    type=#{type}"
        puts "#{prefix}    value=#{value}"
        prefix += '  '
        children.each do |child|
          case child
            when Token
              puts "#{prefix}#{child.to_s}"
            when ASTNode
              child.print_tree(prefix)
          end
        end
      end
    end

    private

    # creates a new counter
    def new_counter
      count = 0
      lambda { count += 1 }
    end
  end

  # An <em>expression</em> in the grammar
  class ExpressionNode < ASTNode
    # the name for the node type
    NODE_TYPE = 'expression'
  end

  # An <em>expression′</em> in the grammar
  class ExpressionPrimeNode < ASTNode
    # the name for the node type
    NODE_TYPE = 'expression′'
  end

  # A <em>term</em> in the grammar
  class TermNode < ASTNode
    # the name for the node type
    NODE_TYPE = 'term'
  end

  # A <em>term′</em> in the grammar
  class TermPrimeNode < ASTNode
    # the name for the node type
    NODE_TYPE = 'term′'
  end

  # An <em>factor</em> in the grammar
  class FactorNode < ASTNode
    # the name for the node type
    NODE_TYPE = 'factor'
  end

  # An <em>base</em> in the grammar
  class BaseNode < ASTNode
    # the name for the node type
    NODE_TYPE = 'base'
  end
end
